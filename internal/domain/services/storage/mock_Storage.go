// Code generated by mockery v2.21.1. DO NOT EDIT.

package storage

import (
	context "context"

	interfaces "github.com/Inspirate789/Thermy-backend/internal/domain/interfaces"
	mock "github.com/stretchr/testify/mock"

	models "github.com/Inspirate789/Thermy-backend/internal/domain/models"
)

// MockStorage is an autogenerated mock type for the Storage type
type MockStorage struct {
	mock.Mock
}

// AddUser provides a mock function with given fields: conn, username, role
func (_m *MockStorage) AddUser(conn ConnDB, username string, role string) error {
	ret := _m.Called(conn, username, role)

	var r0 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, string) error); ok {
		r0 = rf(conn, username, role)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CloseConn provides a mock function with given fields: _a0
func (_m *MockStorage) CloseConn(_a0 ConnDB) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(ConnDB) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllLayers provides a mock function with given fields: conn
func (_m *MockStorage) GetAllLayers(conn ConnDB) ([]string, error) {
	ret := _m.Called(conn)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB) ([]string, error)); ok {
		return rf(conn)
	}
	if rf, ok := ret.Get(0).(func(ConnDB) []string); ok {
		r0 = rf(conn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(ConnDB) error); ok {
		r1 = rf(conn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllModelElements provides a mock function with given fields: conn, layer
func (_m *MockStorage) GetAllModelElements(conn ConnDB, layer string) ([]models.ModelElement, error) {
	ret := _m.Called(conn, layer)

	var r0 []models.ModelElement
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string) ([]models.ModelElement, error)); ok {
		return rf(conn, layer)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string) []models.ModelElement); ok {
		r0 = rf(conn, layer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.ModelElement)
		}
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string) error); ok {
		r1 = rf(conn, layer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllModels provides a mock function with given fields: conn, layer
func (_m *MockStorage) GetAllModels(conn ConnDB, layer string) ([]models.Model, error) {
	ret := _m.Called(conn, layer)

	var r0 []models.Model
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string) ([]models.Model, error)); ok {
		return rf(conn, layer)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string) []models.Model); ok {
		r0 = rf(conn, layer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Model)
		}
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string) error); ok {
		r1 = rf(conn, layer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllProperties provides a mock function with given fields: conn
func (_m *MockStorage) GetAllProperties(conn ConnDB) ([]models.Property, error) {
	ret := _m.Called(conn)

	var r0 []models.Property
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB) ([]models.Property, error)); ok {
		return rf(conn)
	}
	if rf, ok := ret.Get(0).(func(ConnDB) []models.Property); ok {
		r0 = rf(conn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Property)
		}
	}

	if rf, ok := ret.Get(1).(func(ConnDB) error); ok {
		r1 = rf(conn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllUnits provides a mock function with given fields: conn, layer
func (_m *MockStorage) GetAllUnits(conn ConnDB, layer string) (interfaces.OutputUnitsDTO, error) {
	ret := _m.Called(conn, layer)

	var r0 interfaces.OutputUnitsDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string) (interfaces.OutputUnitsDTO, error)); ok {
		return rf(conn, layer)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string) interfaces.OutputUnitsDTO); ok {
		r0 = rf(conn, layer)
	} else {
		r0 = ret.Get(0).(interfaces.OutputUnitsDTO)
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string) error); ok {
		r1 = rf(conn, layer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPropertiesByUnit provides a mock function with given fields: conn, layer, unit
func (_m *MockStorage) GetPropertiesByUnit(conn ConnDB, layer string, unit interfaces.SearchUnitDTO) ([]models.Property, error) {
	ret := _m.Called(conn, layer, unit)

	var r0 []models.Property
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, interfaces.SearchUnitDTO) ([]models.Property, error)); ok {
		return rf(conn, layer, unit)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string, interfaces.SearchUnitDTO) []models.Property); ok {
		r0 = rf(conn, layer, unit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Property)
		}
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string, interfaces.SearchUnitDTO) error); ok {
		r1 = rf(conn, layer, unit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnitsByModels provides a mock function with given fields: conn, layer, modelsID
func (_m *MockStorage) GetUnitsByModels(conn ConnDB, layer string, modelsID []int) (interfaces.OutputUnitsDTO, error) {
	ret := _m.Called(conn, layer, modelsID)

	var r0 interfaces.OutputUnitsDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, []int) (interfaces.OutputUnitsDTO, error)); ok {
		return rf(conn, layer, modelsID)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string, []int) interfaces.OutputUnitsDTO); ok {
		r0 = rf(conn, layer, modelsID)
	} else {
		r0 = ret.Get(0).(interfaces.OutputUnitsDTO)
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string, []int) error); ok {
		r1 = rf(conn, layer, modelsID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUnitsByProperties provides a mock function with given fields: conn, layer, propertiesID
func (_m *MockStorage) GetUnitsByProperties(conn ConnDB, layer string, propertiesID []int) (interfaces.OutputUnitsDTO, error) {
	ret := _m.Called(conn, layer, propertiesID)

	var r0 interfaces.OutputUnitsDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, []int) (interfaces.OutputUnitsDTO, error)); ok {
		return rf(conn, layer, propertiesID)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string, []int) interfaces.OutputUnitsDTO); ok {
		r0 = rf(conn, layer, propertiesID)
	} else {
		r0 = ret.Get(0).(interfaces.OutputUnitsDTO)
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string, []int) error); ok {
		r1 = rf(conn, layer, propertiesID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserPassword provides a mock function with given fields: conn, username
func (_m *MockStorage) GetUserPassword(conn ConnDB, username string) (string, error) {
	ret := _m.Called(conn, username)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string) (string, error)); ok {
		return rf(conn, username)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string) string); ok {
		r0 = rf(conn, username)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string) error); ok {
		r1 = rf(conn, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LayerExist provides a mock function with given fields: conn, layer
func (_m *MockStorage) LayerExist(conn ConnDB, layer string) (bool, error) {
	ret := _m.Called(conn, layer)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string) (bool, error)); ok {
		return rf(conn, layer)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string) bool); ok {
		r0 = rf(conn, layer)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string) error); ok {
		r1 = rf(conn, layer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenConn provides a mock function with given fields: request, ctx
func (_m *MockStorage) OpenConn(request *AuthRequest, ctx context.Context) (ConnDB, string, error) {
	ret := _m.Called(request, ctx)

	var r0 ConnDB
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(*AuthRequest, context.Context) (ConnDB, string, error)); ok {
		return rf(request, ctx)
	}
	if rf, ok := ret.Get(0).(func(*AuthRequest, context.Context) ConnDB); ok {
		r0 = rf(request, ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ConnDB)
		}
	}

	if rf, ok := ret.Get(1).(func(*AuthRequest, context.Context) string); ok {
		r1 = rf(request, ctx)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(*AuthRequest, context.Context) error); ok {
		r2 = rf(request, ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RenameUnit provides a mock function with given fields: conn, layer, oldName, newName
func (_m *MockStorage) RenameUnit(conn ConnDB, layer string, oldName string, newName string) error {
	ret := _m.Called(conn, layer, oldName, newName)

	var r0 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, string, string) error); ok {
		r0 = rf(conn, layer, oldName, newName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveLayer provides a mock function with given fields: conn, name
func (_m *MockStorage) SaveLayer(conn ConnDB, name string) error {
	ret := _m.Called(conn, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(ConnDB, string) error); ok {
		r0 = rf(conn, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveModelElements provides a mock function with given fields: conn, layer, modelElements
func (_m *MockStorage) SaveModelElements(conn ConnDB, layer string, modelElements []string) ([]int, error) {
	ret := _m.Called(conn, layer, modelElements)

	var r0 []int
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, []string) ([]int, error)); ok {
		return rf(conn, layer, modelElements)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string, []string) []int); ok {
		r0 = rf(conn, layer, modelElements)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string, []string) error); ok {
		r1 = rf(conn, layer, modelElements)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveModels provides a mock function with given fields: conn, layer, _a2
func (_m *MockStorage) SaveModels(conn ConnDB, layer string, _a2 []string) ([]int, error) {
	ret := _m.Called(conn, layer, _a2)

	var r0 []int
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, []string) ([]int, error)); ok {
		return rf(conn, layer, _a2)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, string, []string) []int); ok {
		r0 = rf(conn, layer, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}

	if rf, ok := ret.Get(1).(func(ConnDB, string, []string) error); ok {
		r1 = rf(conn, layer, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveProperties provides a mock function with given fields: conn, properties
func (_m *MockStorage) SaveProperties(conn ConnDB, properties []string) ([]int, error) {
	ret := _m.Called(conn, properties)

	var r0 []int
	var r1 error
	if rf, ok := ret.Get(0).(func(ConnDB, []string) ([]int, error)); ok {
		return rf(conn, properties)
	}
	if rf, ok := ret.Get(0).(func(ConnDB, []string) []int); ok {
		r0 = rf(conn, properties)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}

	if rf, ok := ret.Get(1).(func(ConnDB, []string) error); ok {
		r1 = rf(conn, properties)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveUnits provides a mock function with given fields: conn, layer, data
func (_m *MockStorage) SaveUnits(conn ConnDB, layer string, data interfaces.SaveUnitsDTO) error {
	ret := _m.Called(conn, layer, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, interfaces.SaveUnitsDTO) error); ok {
		r0 = rf(conn, layer, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetUnitProperties provides a mock function with given fields: conn, layer, unitName, propertiesID
func (_m *MockStorage) SetUnitProperties(conn ConnDB, layer string, unitName string, propertiesID []int) error {
	ret := _m.Called(conn, layer, unitName, propertiesID)

	var r0 error
	if rf, ok := ret.Get(0).(func(ConnDB, string, string, []int) error); ok {
		r0 = rf(conn, layer, unitName, propertiesID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewMockStorage interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockStorage creates a new instance of MockStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockStorage(t mockConstructorTestingTNewMockStorage) *MockStorage {
	mock := &MockStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
