\section{Конструкторская часть}

% В данном разделе будет проведён анализ существующих операционных систем для устройств интернета вещей. Рассматриваемые операционные системы будут относиться к одному из двух типов: ОС реального времени и ОС разделения времени.

\subsection{Проектирование БД}

\subsubsection{Формализация сущностей системы}

На рисунке ????? представлена диаграмма, отражающая информацию о таблицах проектируемой БД.

...Диаграмма и перечисление атрибутов (с указанием типов)...

Поле <<класс>> в моделях нужно для масштабирования.

\subsubsection{Триггеры БД?}

А они нужны? Если да, то здесь описать, какие триггеры нужны и зачем.

\subsubsection{Ролевая модель}

С какими таблицами (и как) могут работать разные пользователи, имеющие разные роли.



\subsection{Проектирование программного комплекса}

\subsubsection{Архитектура приложения}

Приложение состоит из нескольких элементов: пользовательский интерфейс, базы данных и внешние сервисы. Архитектура приложения определяет, как эти компоненты будут взаимодействовать друг с другом, а также устанавливает границы между разными частями приложения и их ответственностями.

\subsubsubsection{Монолитная архитектура}

Монолитная архитектура --- это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. 
% Монолитом часто называют нечто большое и неповоротливое, и эти два слова хорошо описывают монолитную архитектуру для проектирования ПО. 
Монолитная архитектура представляет собой вычислительную сеть с единой базой кода, в которой объединены все бизнес-задачи. Чтобы внести изменения в такое приложение, необходимо обновить весь стек через базу кода, а также создать и развернуть обновленную версию интерфейса, находящегося на стороне службы. Это ограничивает работу с обновлениями и требует много времени.

Монолитную архитектуру можно использовать на начальных этапах проектов, чтобы облегчить развертывание и управление кодом. Это позволяет сразу выпускать все, что есть в монолитном приложении.

\subsubsubsection{Микросервисная архитектура}

Микросервисная архитектура представляет собой метод организации архитектуры, основанный на ряде независимо развертываемых служб. Эти службы реализуют независимую бизнес-логику и, как правило, имеют собственную базу данных. Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы. Микросервисы разбивают крупные задачи, характерные для конкретного бизнеса, на несколько независимых кодовых баз. Микросервисы в составе приложения должны иметь независимую логику и ограниченную зону ответственности.

% Внедрение микросервисов зачастую тесно связано с DevOps, поскольку они лежат в основе методики непрерывной поставки, которая позволяет командам быстро адаптироваться к требованиям пользователей.

При переходе от монолитной архитектуры к микросервисной возникает задача организации взаимодействия компонентов приложения (в частности, транспорта данных). Соответственно, часть проблем переходит из плоскости кода на инфраструктурный и транспортный уровень.

\subsubsubsection{Выбор архитектуры приложения}

TODO: сравнение и подведение итогов.

%Основные преимущества монолитной архитектуры:
%
%\begin{itemize}[label*=---]
%	\item развертывание (один исполняемый файл);
%	\item ;
%	\item производительность;
%	\item ;
%	\item ;
%	\item ;
%\end{itemize}
%
%Основные недостатки монолитной архитектуры:
%
%\begin{itemize}[label*=---]
%	\item ;
%	\item ;
%	\item ;
%	\item ;
%	\item ;
%	\item ;
%\end{itemize}
%
%Отличительные свойства микросервисов:
%- Микро не обязательно про размер, но про зону ответственности.
%- Самодостаточны, идеальны для горизонтального масштабирования.
%- Разные технологии для разных задач (но крайне нежелательно разводить "зоопарк технологий").
%- Распределенная кодовая база (декомпозиция задач в командной разработке).
%
%Переход на микросервисы повышает отказоустойчивость системы.
%
%Плюсы микросервисного подхода:
%- Независимая разработка.
%- Независимое развёртывание.
%- Независимая масштабируемость.
%- Повторное использование (меньше внутренних зависимостей -> легче повторно использовать код).
%- Проще переписать, чем доработать.
%- Проще юнит тестирование (протестировать относительно небольшую систему с чётко описанными границами проще, чем большую систему, которая под капотом также может взаимодействовать с другимим системами, т.е. иметь связи с другими элементами).
%
%Минусы микросервисного подхода:
%- Возросшая сложность для тестирования (речь про интеграционное тестирование).
%- Возросшая сложность для разработчиков.
%- Возросшая сложность для эксплуатации/Devops.
%- Выше требования к компетенции (учёт версионности и т.д.).
%
%По сути все минусы исходят из того, что при переходе от монолита к микросервисам возникает задача организации их взаимодействия (транспорта данных).
%
%Ещё особенности (по сути ещё минусы):
%- Удаленные вызовы дороже локального исполнения.
%- Реальные системы обычно не имеют чётко определённых границ.
%- Сложности stateful.
%- Версионность и работа с ней.
%- Сложности взаимодействия между сервисами.
%- Распределенные транзакции.
%- Попытка замаскировать монолит.



Выбираем микросервисы, потому что очень сильно выигрываем от плюсов (особенно от разных языков, но пока не говорю, каких).



\subsubsection{Связь компонентов приложения}

\subsubsubsection{REST API}

\subsubsubsection{gRPC}

\subsubsubsection{Выбор взаимодействия компонентов приложения}

gRPC, потому что между сервисами передаётся много данных (структуры, представляющие очень большие тексты), поэтому критически важен быстрый транспорт.



\subsubsection{Структура программного комплекса}

На рисунке ????? представлена структура программного комплекса, оформленная в виде диаграммы развёртывания. Она отражает компоненты, необходимые для работы системы, а также способы их взаимодействия. 

Обязательно здесь упомянуть про контейнеризацию и Docker!



\subsubsection{Диаграммы последовательностей}



\subsubsection{Паттерны проектирования}

Паттерны проектирования повышают степень повторного использования проектных и архитектурных решений. Они помогают выбрать альтернативные решения, упрощающие повторное использование системы, и избежать тех альтернатив, которые его затрудняют. Паттерны улучшают качество документации и сопровождения существующих систем, поскольку они позволяют явно описать взаимодействия классов и объектов, а также причины, по которым система была построена так, а не иначе \cite{patterns}.

Далее будут описаны паттерны проектирования, которые будут использованы при разработке программного комплекса.

% \subsubsubsection{Active Record}

\subsubsubsection{Repository}

Repository (репозиторий) \cite{repository_pattern} --- это слой абстракции, инкапсулирующий в себе всё, что относится к способу хранения данных. Он предназначен для отделения бизнес-логики от деталей реализации слоя доступа к данным.

Паттерн Репозиторий стал популярным благодаря DDD (Domain Driven Design). В отличие от Database Driven Design, в DDD разработка начинается с проектирования бизнес логики, причём во внимание принимаются только особенности предметной области, а всё, что связано с особенностями хранения данных, игнорируется.

Применение данного паттерна не предполагает создание только одного объекта репозитория во всем приложении. Хорошей практикой считается создание отдельных репозиториев для каждого бизнес-объекта или контекста, например: OrdersRepository, UsersRepository, AdminRepository.

Репозиторий --- это высокоуровневая абстракция доступа к данным. Интерфейс каждого конкретного репозитория определяется в слое бизнес-логики наряду с классами предметной области. Реализация каждого репозитория находится в слое доступа к данным (Data Access Layer, DAL), который состоит из реализации каждого репозитория, ORM-специфичных классов, сущностей, классов-сопоставлений (mapping), контекстов данных и т.д.

\subsubsubsection{Dependency injection}

% В терминах объектно-ориентированной разработки программного обеспечения это означает следующее: взаимодействующие классы должны полагаться на инфраструктуру) для предоставления необходимые услуги.

Dependency injection (инъекция зависимостей) \cite{dependency_injection} --- это набор принципов и паттернов проектирования программного обеспечения, который позволяет разрабатывать свободно связанный код.

В программной инженерии внедрение зависимостей --- это техника, при которой один объект предоставляет зависимости другому объекту. Зависимость --- это объект, который может быть использован, например, в качестве сервиса. Вместо того чтобы клиент указывал, какой сервис он будет использовать, что-то указывает клиенту, какой сервис использовать. Инъекция относится к передаче зависимости (сервиса) в объект (клиент), который будет его использовать. Сервис становится частью состояния клиента. Передача сервиса клиенту, вместо того чтобы позволить клиенту создать или найти сервис, является фундаментальным требованием паттерна.

Создание объектов непосредственно в классе является негибким, поскольку фиксирует класс на определенных объектах и делает невозможным дальнейшее изменение инстанцирования независимо от класса. Это не позволяет классу быть многократно используемым, если потребуются другие объекты, и затрудняет тестирование класса, поскольку реальные объекты не могут быть заменены имитационными объектами.

Зависимость от интерфейса является более гибкой, чем зависимость от конкретных классов. Объектно-ориентированные языки предоставляют способы, с помощью которых можно заменить эти абстракции конкретными реализациями во время выполнения. Инъекция зависимостей помогает кодовую базу гибкой и пригодной для повторного использования.



\subsubsubsection{Template method}

Template Method (шаблонный метод) \cite{patterns} --- паттерн поведения классов.

Шаблонный метод определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Это позволяет подклассам переопределять отдельные шаги алгоритма, не меняя его общей структуры.

Основные условия для применения паттерна шаблонный метод:

\begin{itemize}[label*=---]
	\item однократное использование инвариантных частей алгоритма, при этом реализация изменяющегося поведения остается на усмотрение подклассов;
	\item необходимость вычленить и локализовать в одном классе поведение, общее для всех подклассов, чтобы избежать дублирования кода;
	\item управление расширениями подклассов (шаблонный метод можно определить так, что он будет вызывать операции-зацепки (hooks) в определенных точках, разрешив тем самым расширение только в этих точках);
\end{itemize}

Шаблонные методы --- один из фундаментальных приемов повторного использования кода. Они играют особенно важную роль в библиотеках классов, поскольку предоставляют возможность вынести общее поведение в библиотечные классы. Шаблонные методы приводят к инвертированной структуре кода, которая подразумевает, что родительский класс вызывает операции подкласса, а не наоборот.

\pagebreak